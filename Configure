#!/bin/bash

Configure_version="2.100 10/11/04"

if [ -f /proc/kallsyms ]; then
    KSYMS=/proc/kallsyms
else
    KSYMS=/proc/ksyms
fi

## DEBUG
#set -x

usage()
{
cat <<EOF

NAME
       Configure -- configure script for Linux Streams.

SYNOPSIS
       Configure [options] [<config output file name>]

DESCRIPTION
       Collect Linux streams configuration. Interactively by default or
       option parsing.

OPTIONS
       -h,--help Print out this message
       -m|--onmachine Install on this machine [y|n required]
       -l|--levelrun Configure to run in :
                     l=kernel,u=userspace,q=QNX
       -n|--nativecompiler Use native C (or cross compiling) [y|n required] 
       -r|--onrunning Compile on current running kernel [y|n required]
       -s|--ksourcedir Kernel source directory <STRING>
       -v|--versionlinux  Kernel version <STRING> (uname -r) 
       -M|--loadmodules If answer is no must run 'make modules_install' to
                        install modules [y|n required]
       -L|--moduleslocation  Kernel modules location <STRING>
       -b|--backcompat [y|N optional]
                       y =  LiS backward compatible constants 
                       n =  UnixWare/Solaris compatible constants 
       -S|--solaris Use Solaris style cmn_err [y|N optional]
       -g|--sourcedebug Source level debugging [y|n optional]
       -R|--sharedlibs Use shared libraries [Y|n required]
       -c|--intcpuflags  "int or unsigned long" type for CPU [y|n required] 
       -i|--forcenewinode Force new_inode usage (only when not detected)
                       [y|n optional]
       -p|--productioncode Performance enhanced production code [y|n required]
       -I|--inet Attempt to build 'streams-inet' kernel module
       -D|--devbase  Base major device number [value required]
       -N|--noprompt  Don't prompt for options; use defaults
       -t|--comment  Comment text
       -q|--quiet   No console output
       -x|--make    Invoked from 'make'
       -o|--output  Output file name [config.in]
       --pkgcompile Compile (.c) sources in pkg subdirs
       --pkgmodules Build compiled objects in pkg subdirs as modules
       --package	short name of package [LiS]
       --prefix		generic install directory prefix [/usr]
       --execprefix	install prefix for executables [/usr]
       --includedir	where to install gemeric headers [/usr/include]
       --libdir		where to install generic libraries [/usr/lib]
       --bindir		where to install user executables [/usr/bin]
       --sbindir	where to install system executables [/usr/sbin]
       --sysconfdir	where to install system configuration files [/etc]
       --datadir	where to install package-specific subdirs [/usr/share]
       --pkgincludedir	where to install package headers [/usr/include/LiS]
       --pkglibdir	where to install package libraries [/usr/lib/LiS]
       --pkgdatadir	where to install package files [/usr/share/LiS]
       --pkgsrcdir	where to install package sources [/usr/src/LiS]
       --mandir		where to install man pages [/usr/share/man]
       --modsubdir	where to install kernel modules [streams]
       --regparm        0 or 3 for STREAMS regparm interface [0]

EXAMPLE 

 ./Configure --onmachine=n --levelrun=l --nativecompiler=y --onrunning=n 
 --ksourcedir=/usr/src/kernel-headers-2.4.22-1-686-smp 
 --versionlinux=2.4.22-1-686-smp    --loadmodules=n 
 --moduleslocation=/lib/modules/2.4.22-1-686-smp/ --backcompat=n 
 --solaris=n --sourcedebug=y --sharedlibs=y --intcpuflags=n --forcenewinode=y 
 --productioncode=y

EOF
}

setup_opts ()
{
    declare -a opts

    save_IFS=$IFS
    opts=( \
	"onmachine:" "levelrun:" "nativecompiler:" "onrunning:"		\
	"ksourcedir:" "versionlinux:" "loadmodules:" "moduleslocation:" \
	"backcompat::" "solaris::" "sourcedebug::" "sharedlibs:" 	\
	"intcpuflags:" "forcenewinode::" "productioncode:" "inet" 	\
	"noprompt" "devicebase:" "output:" "comment:" "make" "quiet" 	\
	"help" "package:" "prefix:" "execprefix:" "includedir:"		\
	"libdir:" "bindir:" "sbindir:" "sysconfdir:" "datadir:"		\
	"pkgincludedir:" "pkglibdir:" "pkgdatadir:" "pkgsrcdir:"	\
	"mandir:" "modsubdir:" "pkgcompile" "pkgmodules" "regparm:"	\
	"DESTDIR:"
    )
    IFS=","
    longopts="${opts[*]}"
    IFS=$save_IFS
    opts=(\
	"m:" "l:" "n:" "r:" "s:" "v:" "M:" "L:" "b::" "S::" "g::" "R:" \
	"c:" "i::" "p:" "I" "N" "D:" "o:" "t:" "x" "q" "h" )
    IFS=""
    shortopts="${opts[*]}"
    IFS=$save_IFS
}

#=======================================================================
#
# Parse command line options
#

# save options passed in as CONFIG_OPTS
#
CONFIG_OPTS="${*}"

# setup longopts and shortopts
#
setup_opts

# let getopt(1) do its thing...  we use args to be able to preserve
# getopt's exit code.  Thereafter, we convert args to positional parms
# with 'eval set --'
#
args=`getopt -n $(basename $0) -l $longopts -o $shortopts -- "$@"`
if [ $? != 0 ]; then exit 1; fi
eval set -- "$args"

## Set shell variables from parsed options
##
while  true ; do
case "$1" in
    -m|--onmachine) OPT_ONMACHINE=$2; shift 2;;
    -l|--levelrun) OPT_LEVELRUN=$2; shift 2;;
    -n|--nativecompiler) OPT_NATIVECOMPILER=$2; shift 2 ;;
    -r|--onrunning) OPT_ONRUNNINGLNX=$2; shift 2 ;;
    -s|--ksourcedir) OPT_KSOURCEDIR=$2; shift 2 ;;
    -v|--versionlinux) OPT_VERSIONLINUX=$2; shift 2 ;;
    -M|--loadmodules) OPT_LOADMODULES=$2; shift 2 ;;
    -L|--moduleslocation) OPT_MODULESLOCATION=$2; shift 2 ;;
    -b|--backcompat) OPT_BACKCOMPAT=${2:-y}; shift 2 ;;
    -S|--solaris) OPT_SOLARISSTYLE=${2:-y}; shift 2 ;;
    -g|--sourcedebug) OPT_SRCDBG=${2:-y}; shift 2 ;;
    -R|--sharedlibs) OPT_SHAREDLIBS=$2; shift 2 ;;
    -c|--intcpuflags) OPT_INTCPUFLAGS=$2; shift 2 ;;
    -i|--forcenewinode) OPT_FORCENEWINODE=${2:-y}; shift 2 ;;
    -p|--productioncode) OPT_PRODUCTIONCODE=$2; shift 2 ;;
    -I|--inet) OPT_INET=y; shift ;;
    -D|--devicebase) OPT_DEVICEBASE=$2; shift 2 ;;
    -N|--noprompt) OPT_NOPROMPT=y; shift ;;
    -o|--output) OPT_CONFIG=$2; shift 2 ;;
    -t|--comment) COMMENT="$COMMENT$2"; shift 2 ;;
    -x|--make) MAKE_INVOKED=y;  shift ;;
    -q|--quiet) QUIET=y;  shift ;;
    -h|--help) usage ; exit 0;;
    --pkgcompile) OPT_PKGCOMPILE=y; shift ;;
    --pkgmodules) OPT_PKGMODULES=y; shift ;;
    --package) package=$2; shift 2 ;;
    --prefix) prefix=${2:-" "}; shift 2 ;;
    --execprefix) execprefix=${2:-" "}; shift 2 ;;
    --includedir) includedir=$2; shift 2 ;;
    --libdir) libdir=$2; shift 2 ;;
    --bindir) bindir=$2; shift 2 ;;
    --sbindir) sbindir=$2; shift 2 ;;
    --sysconfdir) sysconfdir=$2; shift 2 ;;
    --datadir) datadir=$2; shift 2 ;;
    --pkgincludedir) pkgincludedir=$2; shift 2 ;;
    --pkglibdir) pkglibdir=$2; shift 2 ;;
    --pkgdatadir) pkgdatadir=$2; shift 2 ;;
    --pkgsrcdir) pkgsrcdir=${2:-" "}; shift 2 ;;
    --mandir) mandir=$2; shift 2 ;;
    --modsubdir) modsubdir=$2; shift 2 ;;
    --regparm) STREAMS_REGPARM=$2; shift 2 ;;
    --DESTDIR) DESTDIR=$2; shift 2 ;;
    --) shift; break ;;
    *) echo "$(basename $0): unrecognized option '$1'" >&2; exit 1 ;;
    esac
done

# we expect zero or one unparsed argument, to be used as the file
# name for this script's output.  We need to verify this; if there's
# more than one, the first may be an improperly parsed option or
# option value.
#
if [ $# -gt 1 ]; then
    echo "error - expected <config output file name>" >&2
    exit 1
fi

# set CONFIG - priority to -o|--output <file>, but last arg otherwise;
# default to 'config.in'.  The reason for this priority is that using
# -o|--output ensures no mistake in specifying the file name, but still
# allows optional arguments to be used
#
CONFIG=${OPT_CONFIG:-${1:-config.in}}

# set qecho/qcat to be used for output controlled by QUIET option
#
if [ "$QUIET" = "y" ]; then qecho=: ; qcat=: ; else qecho=echo ; qcat=cat ; fi

#=========================================================================

# argn() usage: argn <n> <args>...
#
argn()
{
    n=$1;  shift;  echo -n $(eval "echo -n \$$n")
}

#
# do_readstring  - Ask for a string
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	DEFAULT is the default response to use for empty input
# Outputs:
#	RESULT has the response from the user
#
do_readstring()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	RESULT=$DEFAULT
	return
    fi

    while true; do
	echo -en "\n$PROMPT"
	if [ "$DEFAULT..." != "..." ]; then
	    echo -n " [default: $DEFAULT] "
	fi

	read RESULT

	if [ "$RESULT..." != "..." ]; then
	    return
	else
	    if [ "$DEFAULT..." != "..." ]; then
		RESULT=$DEFAULT
	        return
	    fi
	fi
    done
}

#
# Write a message to the user and get a CR to continue
#
do_confirm()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	return
    fi

    PROMPT="$1"
    if [ "$1..." != "..." ]; then
	PROMPT="$PROMPT  "
    fi
    PROMPT="${PROMPT}Press Enter to continue... "
    echo -en "\n$PROMPT"
    read DISCARD
}

#
# do_read_dir  - Ask for name of an existing directory
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	DEFAULT is the default response to use for empty input
#       ARGVVALUE is the value collected by ARG parsing -> no interaction
# Outputs:
#	RESULT has the response from the user
#
do_read_dir()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	[ -d "$ARGVALUE" ] && DEFAULT=$ARGVALUE
	do_readstring
	if [ -d "$RESULT" ]; then
	    return 0
	else
	    return 1
        fi
    fi

    n=2
    while :; do
	if [ "$ARGVVALUE..." = "..." ]; then
            #interact with user..
            do_readstring
        else
	    RESULT=${ARGVVALUE}
            # to avoid loops
	    unset ARGVVALUE 
        fi
	if [ -d "$RESULT" ]; then
	    return 0
	fi
	n=`expr $n - 1`
	if [ $n -eq 0 ]; then
	    return 1
	fi
    done
}

#
# do_read_choice  - Ask for a choice
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	RESPONSE has the responses that are valid
#       ARGVVALUE is the value collected by ARG parsing -> no interaction
#	DEFAULT is the default response to use for empty input
# Outputs:
#	RESULT has the response from the user
#
do_read_choice()
{
    if [ -n "$OPT_NOPROMPT" ]; then
	RESULT=${ARGVVALUE:-$DEFAULT}
	return
    fi

    # Check that we have valid responses and default
    if [ "$RESPONSE..." = "..." ]; then
	echo "Internal error."
	exit 1;
    fi
    local VALID_DEFAULT=0
    for i in $RESPONSE; do
        if [ "$ALTERNATE_DEFAULT..." = "..." ]; then
	    local ALTERNATE_DEFAULT=$i
	fi
        if [ "$i" = "$DEFAULT" ]; then
    	    local VALID_DEFAULT=1
	    break
        fi
    done
    if [ "$VALID_DEFAULT" = "0" ]; then
	DEFAULT=
    fi
    if [ "$DEFAULT..." = "..." ]; then
	DEFAULT=$ALTERNATE_DEFAULT
    fi

    while :; do
        if [ "$ARGVVALUE..." = "..." ]; then
         #interact with user..
         do_readstring
         else
         # use the response from CLI
         RESULT=${ARGVVALUE}
        # to avoid loop
        unset  ARGVVALUE
         fi
	for i in $RESPONSE; do
	    if [ "$i" = "$RESULT" ]; then
		return
	    fi
	done
	echo "Unexpected response"
    done
}

#
# default_ksrc
#
# Figure out a good default for kernel source directory
# Do not retain any "../" isms in the path name.
#
default_ksrc()
{
    # Try /usr/src/linux first
    if [ -d /usr/src/linux -o -L /usr/src/linux ]; then
	echo "/usr/src/linux"
	return
    fi

    # Try /lib/modules/<kver>/source next if that exists
    kver=${OPT_VERSIONLINUX:-`uname -r`}
    [ -d /lib/modules/${kver}/source ] || kver=`uname -r`
    ksrc=/lib/modules/${kver}/source

    if [ -L $ksrc ]; then
	ksrc=`ls -l $ksrc | sed -e 's/^.*-> //' -e 's/\.\.\///g'`
	ksrc=/$ksrc
	if [ -d "$ksrc" -o -L "$ksrc" ]; then
		echo $ksrc
		return
	fi
    fi

    # Try /lib/modules/<kver>/build next if that exists
    kver=${OPT_VERSIONLINUX:-`uname -r`}
    [ -d /lib/modules/${kver}/build ] || kver=`uname -r`
    ksrc=/lib/modules/${kver}/build

    if [ -L $ksrc ]; then
	ksrc=`ls -l $ksrc | sed -e 's/^.*-> //' -e 's/\.\.\///g'`
	ksrc=/$ksrc
	if [ -d "$ksrc" -o -L "$ksrc" ]; then
		echo $ksrc
		return
	fi
    fi

    echo "Unknown"
}

#
# check_ksrc
#
# Check to see if the directory $KSRC is present.  If it is set to
# /usr/src/linux and that directory is not present then feel around
# a bit for a substitute to which a symbolic link can be constructed.
#
check_ksrc()
{
    if [ -n "$KSRC" ]; then

	if [ -d "$KSRC" ]; then
	    return 0				# present
	fi

	if [ -L "$KSRC" ]; then
	    (cd $KSRC >/dev/null 2>&1) && return 0 || return 1
	    # return 0			# symbolic link, presume present
	fi

	if [ "$KSRC" != "/usr/src/linux" ]; then
	    # FIXME - why fail if /usr/src/linux is a directory?
	    return 1				# not present
	fi
    fi

    #
    # pick up version string.  It might be like "2.4.2" or it
    # might be like "2.4.2-21smp".
    #
    # - the following (now) works, but `uname -r` is easier...
    #vers=("`cat /proc/version | sed 's:(::g' | sed 's:)::g'`")
    #vers=`argn 3 ${vers}`
    #
    vers=`uname -r`
    trunc_vers=`echo $vers | sed -e 's/-.*//'`
    num_vers=`echo $vers | sed -e 's/[a-zA-Z][a-zA-Z]*//'`

    if [ -d /lib/modules/${vers}/build ]; then
	KSRC=/lib/modules/${vers}/build
    elif [ -d /usr/src/$vers ]; then
	KSRC=/usr/src/$vers
    elif [ -d /usr/src/linux-$vers ]; then
	KSRC=/usr/src/linux-$vers
    elif [ -d /usr/src/linux$trunc_vers ]; then
	KSRC=/usr/src/linux$trunc_vers
    elif [ -d /usr/src/linux-$trunc_vers ]; then
	KSRC=/usr/src/linux-$trunc_vers
    elif [ -d /usr/src/linux$num_vers ]; then
	KSRC=/usr/src/linux$num_vers
    elif [ -d /usr/src/linux-$num_vers ]; then
	KSRC=/usr/src/linux-$num_vers
    else
	return 1				# not present
    fi

    return 0					# present
}

#
# Get config variable from config.h/autoconf.h.  If config.h is not present
# or does not have the config variable, try the "include/config" 
# subdirectory.
#
# $1 is the name of the variable to find.
#
# Return via stdout a "y" if defined or "" if not.
#
ac_get_config()
{
    if [ -f $AUTOCONF_FILE ]; then
	cc -I$KSRC/include -E -dM -D__KERNEL__ \
		-include $AUTOCONF_FILE dummy.c >kconfig
	x=`grep $1 kconfig 2>&1`
	if [ $? -eq 0 ]; then			# found it
	    if expr "$x" : "#define" >/dev/null 2>/dev/null; then
		echo -n "y"			# option selected
		return 0			# found
	    fi
	    if expr "$x" : "#undef" >/dev/null 2>/dev/null; then
		return 0			# found, but empty
	    fi
	fi
	#
	# If autoconf.h is present but our option is not mentioned
	# in a #define, then it must be in a #undef.  So assume
	# that the option is "found" but not set.
	#
	return 0				# found, but empty
    fi
						# no autoconf.h
    return 1					# not found
}

#
# Get config variable from .config
#
# $1 is the name of the variable to find, of the form "VAR=y".
#
# Return via stdout a "y" if defined or "" if not.
#
dc_get_config()
{
    x=`grep $1 $KSRC/.config 2>&1`
    if [ $? -ne 0 ]; then
	return 1
    fi
    echo -n "y"
    return 0			# found
}

#
# Get config variable from .config
#
# $1 is the name of the variable to find, of the form "VAR=<value>".
#
# Return via stdout <value> if defined or "" if not.
#
dc_get_config_val()
{
    x=`grep $1 $KSRC/.config 2>&1`
    if [ $? -ne 0 ]; then
	return 1
    fi
    echo $x | awk -F'=' '{print $2}'
    return 0			# found
}

#
# Get System.map file name on a Red Hat system
# 5.2 has one of them in /boot, 6.0 has several with a symbolic
# link from System.map to the one that is in use.
#
# This is only meaningful if the user intends to run LiS on the
# machine on which he is installing it.  So ask first.
#
# Return 0 (true) if found
#
rh_get_system_map()
{
    if [ "$BEEN_HERE_DONE_THIS..." = "1..." ]; then
	if [ "$SMAP..." = "..." ]; then
	    return 1
	fi
	return 0
    fi

    SMAP=
    PROMPT="\
Is it your intent to run LiS on the same machine on which\n\
you are installing it?  Or are you intending to cross compile\n\
for another machine?\n\
    y = I am going to run it on this machine\n\
    n = I am not going to run it on this machine\n\
Please enter y or n"
    RESPONSE="y n"
    DEFAULT=y
    ARGVVALUE="$OPT_ONMACHINE"
    do_read_choice
    BEEN_HERE_DONE_THIS=1
    if [ "$RESULT..." = "n..." ]; then
	echo
	echo "You really should load your kernel source and build"
	echo "your kernel before installing LiS."
	echo
	do_confirm
	return 1
    fi

    if [ ! -d /boot ]; then
	return 1
    fi
    if [ ! -L /boot/System.map ]; then
	files=`ls /boot/System.map*`
	if [ $? -ne 0 ]; then
	    return 1
	fi
	nfiles=0
	for i in $files; do
	    nfiles=`expr $nfiles + 1`
	done
	if [ $nfiles -ne 1 ]; then	# need just one of them
	    return 1
	fi

	SMAP=$i				# save file name
    else				# it's a symbolic link
	SMAP=/boot/System.map
    fi
    return 0
}

#
# Check for places that version.h may be hiding.  Try to establish it
# in the kernel source tree where it belongs.
#
check_kver()
{
    #
    # SuSE 7.2 lacks a version.h in the kernel source tree but has one
    # in /boot -- presumably paired with the running kernel version.
    # We will attempt to copy it if it is there and not care whether or
    # not the copy fails.  If we need a version.h in kernel source and
    # it isn't there then we will just write a message and terminate the
    # install.
    #
    if [    ! -f $KSRC/include/linux/version.h \
    	 -a -f /boot/vmlinuz.version.h \
	 -a -d $KSRC/include/linux \
       ]
    then
	cp /boot/vmlinuz.version.h $KSRC/include/linux/version.h \
		>/dev/null 2>/dev/null
    fi
}

#
# Try to extract the kernel version info from the version.h file
# The argument is the full pathname of the version.h file to extract
# from.
#
get_vers_h()
{
    if [ -f $1 ]; then
	cc -I$KSRC/include -E -dM -include $1 dummy.c > kver
	KVER_H=`grep UTS_RELEASE kver | \
	     sed -e 's/^.*UTS_RELEASE.//' -e's/"//g' -e's/  *$//'`
	NKVER_H=`echo $KVER_H | sed -e 's/-.*//'`
    fi
}

#
# parse the kernel version identifier into its components
#
# $1 is the kernel version string
#
parse_kver()
{
    KVER_PATCH=`echo $1|sed -e "s/[^\.]\.[^\.]\.//"`
    KVER_PATCHNO=`echo $KVER_PATCH | sed -e 's/-.*//' -e 's/[^0-9].*//'`
    KVER_MAJORMINOR=`echo ${KVER}|sed -e "s/\.${KVER_PATCH}//"`
    KVER_MINOR=`echo ${KVER_MAJORMINOR}|sed -e "s/[^\.]\.//"`
    KVER_MAJOR=`echo $1|sed -e "s/\.${KVER_MINOR}\.${KVER_PATCH}//"`
}

#
# Figure out kernel version
# Return the version string in KVER (e.g. 2.2.6)
#
get_kver()
{
    check_kver

    # The UTS_RELEASE define got moved (AGAIN) to another location in RHEL6.
    # The UTS_RELEASE define got moved to another file in RHEL5.
    # why?  Because DIFFERENT IS BETTER!
    if [ -f $KSRC/include/generated/utsrelease.h ]; then
	    get_vers_h $KSRC/include/generated/utsrelease.h
    elif [ -f $KSRC/include/linux/utsrelease.h ]; then
	    get_vers_h $KSRC/include/linux/utsrelease.h
    else
	    get_vers_h $KSRC/include/linux/version.h
    fi
    
    if [ -n "$OPT_VERSIONLINUX" ]; then
	KVER=$OPT_VERSIONLINUX
    fi
    if [ -n "$KVER" ]; then
	$(test "$KVER" = "$(uname -r)") && USE_RUNNING_KERNEL=y
    fi
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	KVER=`uname -r`
    elif [ -n "$KSRC" ]; then
	if [ -n "$KVER_H" ]; then
	    KVER=$KVER_H
	elif [ -f $KSRC/vmlinux ]; then
	    KVDEC=`nm -g $KSRC/vmlinux | grep Version_ | sed -e 's/^.*_//'`
	    KMAJ=`expr $KVDEC / 65536`
	    KMIN=`expr $KVDEC / 256`
	    KMIN=`expr $KMIN % 256`
	    KPCH=`expr $KVDEC % 256`
	    KVER="$KMAJ.$KMIN.$KPCH"
	elif grep -q "Red Hat" /etc/issue && rh_get_system_map; then
	    KVDEC=`grep Version_ $SMAP | sed -e 's/^.*_//'`
	    KMAJ=`expr $KVDEC / 65536`
	    KMIN=`expr $KVDEC / 256`
	    KMIN=`expr $KMIN % 256`
	    KPCH=`expr $KVDEC % 256`
	    KVER="$KMAJ.$KMIN.$KPCH"
	else
	    echo "The file $KSRC/include/generated/utsrelease.h"
	    echo "or $KSRC/include/linux/utsrelease.h or"
	    echo "$KSRC/include/linux/version.h is not present."
	    echo "LiS installation cannot proceed without it.  Please fix"
	    echo "this problem and then try the installation again."
	    exit 1
	fi
    else
	KVER=`uname -r`
    fi
    # Remove the extra version glarf from the end of kernel version
    NKVER=`echo $KVER | sed -e 's/-.*//'`
    parse_kver $KVER
}


#
# Having dug out the kernel version from the kernel source info, now
# verify that the currently running kernel has the same settings.
#
kver_h_err_msg()
{
    echo
    echo "Your kernel source is for kernel version $KVER_H, but"
    echo "your running kernel is version $PKVER.  Installation"
    echo "will proceed by may encounter problems later."
    echo
    do_confirm
}

verify_kver()
{
    if [ ! -f /proc/sys/kernel/osrelease ]; then
	echo
	echo "The kernel version cannot be verified because there"
	echo "is no /proc/sys/kernel/osrelease present on the system."
	echo "Chances are that you will experience some kind of problem in"
	echo "loading or running LiS.  This problem really should"
	echo "be rectified before continuing with the installation."
	echo
	do_confirm
	return
    fi

    PKVER=`cat /proc/sys/kernel/osrelease`
    NPKVER=`echo $PKVER | sed -e 's/-.*//'`
    if [ "$NKVER" != "$NPKVER" ]; then
	echo
	echo "Your kernel source is for kernel version $NKVER, but"
	echo "your running kernel is version $NPKVER.  This is a"
	echo "good indication that you are not running on the kernel"
	echo "represented by the kernel source.  Please make the"
	echo "running kernel the same as the one in kernel source and"
	echo "then install LiS again."
	echo
	do_confirm
	exit 1
    fi

    if [ "$KVER_H..." = "..." ]; then
	echo
	echo "The file $KSRC/include/generated/utsrelease.h"
	echo "or $KSRC/include/linux/utsrelease.h or"
	echo "$KSRC/include/linux/version.h is missing."
	echo "LiS needs thie file in order to build properly."
	echo "This may be an indication that there is no kernel"
	echo "source on this machine, or only partial kernel source."
	echo
	do_confirm
	exit 1
    fi

    if [ "$NKVER_H..." != "$NPKVER..." ]; then
	echo
	echo "Your kernel source is for kernel version $NKVER_H, but"
	echo "your running kernel is version $NPKVER.  This is a"
	echo "good indication that you are not running on the kernel"
	echo "represented by the kernel source.  Please make the"
	echo "running kernel the same as the one in kernel source and"
	echo "then install LiS again."
	echo
	do_confirm
	exit 1
    fi

    if [ "$KVER_H..." != "$PKVER..." ]; then
	if [ -f /boot/vmlinuz.version.h ]; then
	    OKVER_H=$KVER_H
	    get_vers_h /boot/vmlinuz.version.h
	    if [ "$KVER_H..." = "$PKVER..." ]; then
		echo
		echo "Your kernel source is for kernel version $OKVER_H, but"
		echo "your running kernel is version $PKVER.  However,"
		echo "the file /boot/vmlinuz.version.h has the correct"
		echo "information it it.  Installation will proceed by"
		echo "copying this file to $KSRC/include/linux/version.h."
		echo
		do_confirm
		if [ ! -f $KSRC/include/linux/version.h.orig ]; then
		    mv  $KSRC/include/linux/version.h \
			$KSRC/include/linux/version.h.orig
		fi
		cp -f /boot/vmlinuz.version.h $KSRC/include/linux/version.h
	    else
		kver_h_err_msg
	    fi
	else
	    kver_h_err_msg
	fi
    else
	echo "Kernel version verified between kernel source and running kernel"
    fi
}

#
# Red Hat helper for getting SMP info
#
# Return 0 (true) if found, 1 (false) if not
#
rh_get_smp()
{
    if ! grep -q "Red Hat" /etc/issue || ! rh_get_system_map; then
	return 1
    fi

    if grep -w -q $SMP_GREP_ID $SMAP; then
	NEED_KSMP=0
	KSMP=y			# SMP kernel
    else
	KSMP=			# non-SMP kernel
    fi
    return 0			# got info
}

#
# Get SMP or not
# Return result in KSMP
#
get_smp()
{
    NEED_KSMP=0				# default is "found"
#    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
#	if grep -q $SMP_GREP_ID $KSYMS; then
#	    KSMP=y
#	else
#	    KSMP=
#	fi
#    else
	KSMP=`ac_get_config CONFIG_SMP`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    : OK
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q $SMP_GREP_ID; then
		KSMP=y			# SMP kernel
	    else
		KSMP=			# non-SMP kernel
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    KSMP=`dc_get_config "CONFIG_SMP=y"`
	else
	    NEED_KSMP=1			# still need the option
	fi
#    fi

    if [ "$KSMP..." = "y..." ]; then
	$qecho "Kernel support for SMP detected."
    else
	$qecho "No kernel support for SMP detected."
    fi
}

#
# Get XEN kernel or not
# Return result in KXEN
#
get_xen()
{
	if [ -f $KSRC/.config ]; then
	    KXEN=`dc_get_config_val "CONFIG_XEN_INTERFACE_VERSION"`
	fi

	if [ "$KXEN..." = "..." ]; then
		$qecho "No kernel support for XEN detected."
	else
		$qecho "Kernel support for XEN detected."
	fi
}

#
# Helper routine for Red Hat systems.  This is invoked when there
# is no vmlinux available.  If the system is Red Hat we look at the
# System.map file in /boot for some of our information.
#
# Return 0 (true) if found, 1 (false) if not
#
rh_get_modules()
{
    if ! grep -q "Red Hat" /etc/issue || ! rh_get_system_map; then
	return 1
    fi

    if grep -q init_modules $SMAP; then
	NEED_KMODULES=0
	KMODULES=y			# Module support
	if grep -q unregister_chrdev_R $KSYMS; then
	    KMODVERS=y
	else
	    KMODVERS=
	fi
    else
	KMODULES=			# No module support
    fi
    return 0
}

#
# Get Modules or not
# Return result in KMODULES
#
get_modules()
{
    NEED_KMODULES=0				# default is "found"
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	KMODULES=y
	if [ "$KVER_MAJORMINOR" = "2.6" ]; then
	    KMODVERS=`ac_get_config CONFIG_MODVERSIONS`
	elif grep -q schedule_R $KSYMS; then
	    KMODVERS=y
	else
	    KMODVERS=
	fi

    else
	KMODULES=`ac_get_config CONFIG_MODULES`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    KMODVERS=`ac_get_config CONFIG_MODVERSIONS`
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q init_modules; then
		KMODULES=y			# module support
		if strings $KSRC/vmlinux |grep -q Using_Versions; then
		    KMODVERS=y
		else
		    KMODVERS=
		fi
	    else
		KMODULES=			# non-module support
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    KMODULES=`dc_get_config "CONFIG_MODULES=y"`
	    if [ "$KMODULES..." = "y..." ]; then
		KMODVERS=`dc_get_config "CONFIG_MODVERSIONS=y"`
	    fi
	else
	    NEED_KMODULES=1			# still need the option
	fi
    fi

    if [ "$KMODVERS..." = "y..." ]; then
	if [ "$KVER_MAJORMINOR" = "2.6" ]; then
	    echo '/* Configure generated dummy file for 2.6 */' \
	    		>${SRCDIR}/include/sys/modversions.h
	    LISMODVERS=y
	fi
	$qecho "Kernel support for mod-versions detected."
    else
	$qecho "No kernel support for mod-versions detected."
    fi
}

#
# Get the IPV6 configuration option from kernel
#
get_ipv6()
{
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q ipv6_addr_type $KSYMS; then
	    IPV6=y
	else
	    IPV6=
	fi
    else
	IPV6=`ac_get_config CONFIG_IPV6`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    : OK
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q ipv6_addr_type; then
		IPV6=y			# SMP kernel
	    else
		IPV6=			# non-SMP kernel
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    IPV6=`dc_get_config "CONFIG_IPV6=y"`
	else
	    IPV6=
	    echo "Cannot determine if kernel supports IPV6, assume not."
	fi
    fi

    if [ "$IPV6..." = "y..." ]; then
	$qecho "Kernel support for IP version 6 detected."
    else
	$qecho "No kernel support for IP version 6 detected."
    fi
}

get_ipv6_module()
{
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q tcp_openreq_cachep $KSYMS; then
	    IPV6_MODULE=y
	else
	    IPV6_MODULE=
	fi
    else
	IPV6_MODULE=`ac_get_config CONFIG_IPV6_MODULE`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    : OK
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q tcp_openreq_cachep; then
		IPV6_MODULE=y			# SMP kernel
	    else
		IPV6_MODULE=			# non-SMP kernel
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    IPV6_MODULE=`dc_get_config "CONFIG_IPV6_MODULE=y"`
	else
	    IPV6_MODULE=
	    echo "Cannot determine if kernel supports IPV6_MODULE, assume not."
	fi
    fi

    if [ "$IPV6_MODULE..." = "y..." ]; then
	$qecho "Kernel support for IP version 6 modules detected."
    else
	$qecho "No kernel support for IP version 6 modules detected."
    fi
}

#
# Figure out whether we should be compiled with -mregparm=n for register
# passing of arguments.
#
get_regparm()
{
    CCREGPARM=
    if [ "$TARGET" = "l" ]; then
	if [ -f $KSRC/drivers/base/firmware_class.ko ] && \
	     strings $KSRC/drivers/base/firmware_class.ko | grep vermagic | \
	     grep REGPARM
	then
	    CCREGPARM="-mregparm=3"
	elif [ -f $AUTOCONF_FILE ]; then
	    regparm_defined=`ac_get_config CONFIG_REGPARM`
	    if [ "$regparm_defined..." = "y..." ]; then
		CCREGPARM="-mregparm=3"
	    else
		CCREGPARM="-Dccregparm=0"
	    fi
	else
	    CCREGPARM="-Dccregparm=0"
	fi

	if [ -z "$ARCH" ]
	then
	ARCH=`uname -m | sed -e s/i.86/i386/ \
			     -e s/sun4u/sparc64/ \
			     -e s/arm.*/arm/ \
			     -e s/sa110/arm/`
	fi
	
	if [ "$ARCH" = "i386" -a \
	     $KVER_MAJOR -ge 2 -a $KVER_MINOR -ge 6 -a $KVER_PATCHNO -gt 19 ]
	then
		# After 2.6.19 (specifically v2.6.19-1474-ga1a70c2)
		# all the above tricks will not recognize REGPARM, but
		# it's always enabled, so just set it.
		CCREGPARM="-mregparm=3"
	fi

	if [ "$CCREGPARM" = "-mregparm=3" ]; then
	    echo "Kernel compiled using register passing for parameters"
	else
	    echo "Kernel compiled using stack passing for parameters"
	fi
    elif [ "$TARGET" = "u" ]; then
	CCREGPARM="-Dccregparm=0"
    fi
    export CCREGPARM
}

#
# Try and determine if struct inode in include/linux/fs.h uses i_private
# or u.generic_ip.  Because it's just too damn hard to leave well enough alone.
#
get_fs_h()
{
	STRUCT_INODE_IPRIVATE=n

	# check that we don't find generic_ip first...
	grep generic_ip $KSRC/include/linux/fs.h > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
		STRUCT_INODE_IPRIVATE=n
	else
		# then check to see if we have i_private.
		grep i_private $KSRC/include/linux/fs.h > /dev/null 2>&1
		if [ $? -eq 0 ]
		then
			STRUCT_INODE_IPRIVATE=y
		else
			echo "Did not find generic_ip nor i_private in"
			echo "$KSRC/include/linux/fs.h."
			echo "Compilation will likely fail..."
		fi
	fi
}


#
# From /proc/ksyms, generate a C header file with defines for all
# of the version-mangled symbol names.
#
generate_symbol_names()
{
    grep _R $KSYMS | sed -e 's/^.........//' -e 's/[ 	].*//' |
    	sed 's/\(.*\)_R\(.*\)/#define \1 \1_R\2/'
}

#
# From what LiS has gleaned from /proc, generate a little autoconf.h
# file that has the correct settings for MODULES, MODVERSIONS and SMP.
#
generate_autoconf()
{
    acf="include/sys/autoconf.h"
    echo '/* THIS FILE WAS GENERATED.  MANUAL CHANGES MAY BE LOST. */' >$acf

    if [ "$KSMP" = "y" ]; then
	echo "#define CONFIG_SMP 1" >>$acf
    else
	echo "#undef CONFIG_SMP" >>$acf
    fi
    if [ "$KMODULES" = "y" ]; then
	echo "#define CONFIG_MODULES 1" >>$acf
    else
	echo "#undef CONFIG_MODULES" >>$acf
    fi
    if [ "$KMODVERS" = "y" ]; then
	echo "#define CONFIG_MODVERSIONS 1" >>$acf
    else
	echo "#undef CONFIG_MODVERSIONS" >>$acf
    fi
    LISAUTOCONF=y
}

#
# get_empty_inode_option
#
# Try to find out whether or not the routine that gets an empty inode
# is still called "get_empty_inode" or "new_inode".
#
# we assume this option will be passed a value s; this makes it easier
# to define the macro conventionally
#
# This must be done after it is known whether we are going to install
# on the running kernel and whether there is kernel source available.
#
get_empty_inode_option()
{
    if [ "$TARGET" != "l" ]; then
	return				# not relevant unless Linux kernel
    fi

    if [ "$KVER_MAJORMINOR" = "2.6" ]; then
       GET_EMPTY_INODE="new_inode((LIS_SB))"
    elif [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q new_inode $KSYMS; then
	    GET_EMPTY_INODE="new_inode((LIS_SB))"
	elif grep -q get_empty_inode $KSYMS; then
	    GET_EMPTY_INODE="get_empty_inode()"
	else
	    GET_EMPTY_INODE="get_empty_inode()"
	    echo "Your running kernel exports neither the symbol"
	    echo "get_empty_inode nor new_inode.  The compilation of"
	    echo "LiS will probably print warnings related to"
	    echo "these symbols, and LiS will probably fail to"
	    echo "load as a module."
	    do_confirm
	fi
	return
    elif [ -f $KSRC/kernel/ksyms.c ]; then
	if grep -q new_inode $KSRC/kernel/ksyms.c; then
	    GET_EMPTY_INODE="new_inode((LIS_SB))"
	elif grep -q get_empty_inode $KSRC/kernel/ksyms.c; then
	    GET_EMPTY_INODE="get_empty_inode()"
	else
	    GET_EMPTY_INODE="get_empty_inode()"
	    echo "Your kernel source exports neither the symbol"
	    echo "get_empty_inode nor new_inode.  The compilation of"
	    echo "LiS will probably print warnings related to"
	    echo "these symbols, and LiS will probably fail to"
	    echo "load as a module."
	     if [ "$OPT_FORCENEWINODE..." = "..." ] ;then
	      do_confirm
             else
                 if  [ "$OPT_FORCENEWINODE" = "y" ] ;then
             	    GET_EMPTY_INODE="new_inode((LIS_SB))" 
                    #echo "***new_inode FORCED***"
		    NEW_INODE_FORCED=" (forced)"
                else
           	    GET_EMPTY_INODE="get_empty_inode()" 
                fi
             fi
	fi
	return
    else
	GET_EMPTY_INODE="get_empty_inode()"
	echo "You have told the LiS installation that you do not"
	echo "intend to run LiS on the running kernel and we cannot"
	echo "find the file $KSRC/kernel/ksyms.c"
	echo "One or the other is necessary to determine whether"
	echo "to use get_empty_inode or new_inode.  The compilation of"
	echo "LiS will probably print warnings related to"
	echo "these symbols, and LiS will probably fail to"
	echo "load as a module."
        if [ "$OPT_FORCENEWINODE..." = "..." ] ;then
            do_confirm
        else
            if  [ "$OPT_FORCENEWINODE" = "y" ] ;then
                GET_EMPTY_INODE="new_inode((LIS_SB))" 
                #echo "***new_inode FORCED***"
		NEW_INODE_FORCED=" (forced)"
            else
                GET_EMPTY_INODE="get_empty_inode()" 
            fi
        fi
    fi

    $qecho "GET_EMPTY_INODE=${GET_EMPTY_INODE}${NEW_INODE_FORCED}"
}

set_cpus_allowed_option()
{
    if [ "$TARGET" != "l" ]; then
	return				# not relevant unless Linux kernel
    fi

    SCHED_H=$KSRC/include/linux/sched.h
    if grep -q set_cpus_allowed $SCHED_H; then
	SET_CPUS_ALLOWED=y
    else
	SET_CPUS_ALLOWED=n
    fi
}

get_cross_compiler_info()
{
	if [ -f cross-compile ]
	then
		# Get definition for cross compiler prefix and ARCH.
		source ./cross-compile
		CROSS_COMPILER_NAME=${CROSS_COMPILE}gcc
	else
		DEFAULT=gcc
		PROMPT="Enter the name of the cross compiler: "
		do_readstring
		CROSS_COMPILER_NAME=$RESULT
		# 26 Mar 2010 MarkS@Adax - if cross compiling and the user 
		# specifies a WindRiver cross compiler don't use -dumpmachine
		# to determine the PREFIX as it will break cross compilation
		# using WindRiver PNE Linux 2.0 SDK which requires we use WindRiver
		# provided wrapper scripts as the compiler name in order to set 
		# things like --sysroot= and -m64.  Also don't use -dumpmachine
		# if the user specifies gcc as the compiler which they might do
		# if they want to install locally to an empty directory.
		# In these cases just strip off "gcc" to determine PREFIX (it is
		# ok that PREFIX end up null when gcc is specified).
		echo "$CROSS_COMPILER_NAME" | grep 'wrs-linux' > /dev/null 2>&1
		wrs=$?
		if [ $wrs -eq 0 -o "$CROSS_COMPILER_NAME" = "gcc" ]
		then
		PREFIX=`echo "$CROSS_COMPILER_NAME" | sed -e 's/gcc//'`
		echo "CROSS_COMPILE=${PREFIX}" > cross-compile
		else
		PREFIX=`$CROSS_COMPILER_NAME -dumpmachine`
		echo "CROSS_COMPILE=${PREFIX}-" > cross-compile
		fi

		DEFAULT=i386
		PROMPT="Enter the name of the architecture: "
		do_readstring
		ARCH=$RESULT
		# Make sure the user doesn't enter anything wonky like i686
		ARCH=`echo $ARCH | sed -e s/i.86/i386/ \
			     -e s/sun4u/sparc64/ \
			     -e s/arm.*/arm/ \
			     -e s/sa110/arm/`

		echo "ARCH=${ARCH}" >> cross-compile
	fi
	CC_VERS=`$CROSS_COMPILER_NAME -dumpversion`

	# 26 Mar 2010 MarkS@Adax - if cross compiling and the target
	# architecture is x86_64, and the cross compiler specified 
	# is WindRiver (wrs-linux in the compiler name provided) then 
	# substitute for "64" with "32" in the compiler name so that 
	# we can compile the libc32over64 libraries.  This is necessary
	# because of the way WindRive PNE Linux 2.0 SDK implemented 
	# their cross compiler toolchain.  Note: CC_NAME32 is used in
	# libc32over64/linux/Makefile.
	if [ "$ARCH" = "x86_64" ]
	then
	if [ `echo $CROSS_COMPILER_NAME | grep 'wrs-linux'` ]
	then
		if [ `echo $CROSS_COMPILER_NAME | grep '64'` ]
		then
		CC_NAME32=`echo $CROSS_COMPILER_NAME | sed -e 's/64/32/'`
		fi
	fi
	fi
}

#
# check the compiler version used to compile the kernel against
# the version info of various C compilers that are available.
#
C_compiler_version()
{
# 23 Aug 2007 MarkS@Adax - if cross compiling, it does not make sense 
# to check various C compiler versions since we already know which 
# compiler to use based on the content of the cross-compile file.
# We assume that the compiler referenced in the cross-compile file
# is the one used to build the kernel.
if [ $CROSS_COMPILING = "y" ]
then
	get_cross_compiler_info
else
    if [ ! -x /usr/bin/$1 ]; then
	return 1
    fi

    CC_VERS=`/usr/bin/$1 -v 2>&1 | \
    	    grep 'gcc version' | \
	    sed -e 's/^.*gcc version // ' -e 's/ .*//' -e 's/^.*-//'`

fi
    echo $CC_VERS
}

kernel_cc_version()
{
# 23 Aug 2007 MarkS@Adax - if cross compiling, it does not make sense 
# to determine the CC version from the local /proc/version file.  If 
# cross compiling, get the CC version from the compiler specified 
# in the cross-compile file.
if [ $CROSS_COMPILING = "y" ]
then
	get_cross_compiler_info
	V=$CC_VERS
else
    V=`cat /proc/version | \
    	    grep 'gcc version' | \
	    sed -e 's/^.*gcc version // ' -e 's/ .*//' -e 's/^.*-//'`
fi
    echo $V
}

pick_a_c_compiler()
{
# 23 Aug 2007 MarkS@Adax - Why pick a c compiler if one is already 
# specified in the cross-compile file?  If cross compiling get the 
# compiler name from the cross-compile file.
if [ $CROSS_COMPILING = "y" ]
then
	get_cross_compiler_info
	echo $CROSS_COMPILER_NAME
	return 0
else

    KERN_CC_VERS=`kernel_cc_version`
    if [ "$KERN_CC_VERS..." = "..." ]; then
	return 1
    fi

    CC_VERS=`C_compiler_version kgcc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo kgcc
	return 0
    fi

    CC_VERS=`C_compiler_version gcc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo gcc
	return 0
    fi

    CC_VERS=`C_compiler_version gcc3`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo gcc3
	return 0
    fi

    CC_VERS=`C_compiler_version cc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo cc
	return 0
    fi
fi
    return 1
}

# the 'kbuild' build process originated with 2.5.x kernels.  Prior to
# 2.6.6, it required '-DKBUILD_MODNAME=...' for modules.  As of 2.6.6,
# that is no longer necessary, but kernel exported symbols must be
# passed into kbuild.  
# For 2.6.16 kernels, they changed this yet again and there are new defines
# for KERNEL_MODNAME and KERNEL_BASENAME.  See head/linux/Makefile 
# and drivers/linux/Makefile for the defines.  These are enabled with 
# KBUILD_NEEDS_MODNAME_REDEF below.
# We define these conditions via the following function
#
check_kbuild()
{
    if [ "$TARGET" != "l" ]; then
	return
    fi
    [ ${KVER_MAJOR} -eq 2 -a ${KVER_MINOR} -ge 5 ] && KBUILD=y || KBUILD=n

    [ "${KBUILD}" = "y" -a ${KVER_MINOR} -eq 6 -a ${KVER_PATCHNO} -ge 4 ] && \
	KBUILD_NEEDS_SYMVERS=y || :

    [ "${KBUILD}" = "y" -a ! "${KBUILD_NEEDS_SYMVERS}" = "y" ] && \
	KBUILD_NEEDS_MODNAME=y || :

    [ "${KBUILD}" = "y" -a ${KVER_MINOR} -eq 6 -a ${KVER_PATCHNO} -ge 16 ] && \
	KBUILD_NEEDS_MODNAME_REDEF=y || :

    [ "${KBUILD}" = "y" ] && MODULE_INIT_TOOLS=y || MODUTILS=y

    if [ "$KBUILD_NEEDS_SYMVERS" = "y" ]; then
	if ls $KSRC/modversions-* >/dev/null 2>/dev/null; then
	    KSYMVERS=`ls -rt $KSRC/modversions-* 2>/dev/null | tail -1`
	else			# define it whether present or not
	    KSYMVERS=$KSRC/Module.symvers
	fi
    fi
}

#=========================================================================

$qecho "LiS Configure script version $Configure_version" "$COMMENT"
$qecho

# if not set, set SRCDIR to directory where this script lives.  Get the
# actual directory name, not a symlink.
#
SRCDIR=$(cd ${SRCDIR:-$(dirname $0)}; pwd)
if [ -L $SRCDIR ]; then
    SRCDIR=`ls -ld $SRCDIR | sed -e 's/^.* //'`
fi

# set CONFIG to an absolute path name; if prefixed with ./, prefix with
# pwd; otherwise if relative (no leading /), prefix with SRCDIR
#
_config=$(echo -n $CONFIG | sed 's:^\./::')
if [ "$_config" != "$CONFIG" ]; then
	CONFIG=$(pwd)/${_config}
fi
unset _config
if [ "$(echo -n $CONFIG | sed 's:^/::')" = "$CONFIG" ]; then
	CONFIG=${SRCDIR}/${CONFIG}
fi

# function to convert '//' -> '/' and strip trailing '/'
#
cleanup_dir()
{
    sed -e "s:\/\/:/:g" | sed -e "s:\/$::"
}

# set directory defaults
#
package=`echo ${package:-LiS} | cleanup_dir`
prefix=`echo ${prefix:-} | cleanup_dir`
uprefix=${prefix}/usr
execprefix=`echo ${execprefix:-${uprefix}} | cleanup_dir`
includedir=`echo ${includedir:-${uprefix}/include} | cleanup_dir`
libdir=`echo ${libdir:-${uprefix}/lib} | cleanup_dir`
lib64dir=`echo ${libdir:-${uprefix}/lib64} | cleanup_dir`
bindir=`echo ${bindir:-${execprefix}/bin} | cleanup_dir`
sbindir=`echo ${sbindir:-${execprefix}/sbin} | cleanup_dir`
sysconfdir=`echo ${sysconfdir:-${prefix}/etc} | cleanup_dir`
datadir=`echo ${datadir:-${uprefix}/share} | cleanup_dir`
pkgincludedir=`echo ${pkgincludedir:-${includedir}/${package}} | cleanup_dir`
pkglibdir=`echo ${pkglibdir:-${libdir}/${package}} | cleanup_dir`
pkgdatadir=`echo ${pkgdatadir:-${datadir}/${package}} | cleanup_dir`
pkgsrcdir=`echo ${pkgsrcdir:-${uprefix}/src/${package}} | cleanup_dir`
mandir=`echo ${mandir:-${datadir}/man} | cleanup_dir`
modsubdir=`echo ${modsubdir:-misc} | cleanup_dir`

# uncomment the following line to see what OPT_ variables are set
#set | grep '^OPT_' | $qcat
$qecho "CONFIG=$CONFIG"
$qecho
$qecho "package=${package}"
$qecho "prefix=${prefix}"
$qecho "execprefix=${execprefix}"
$qecho "includedir=${includedir}"
$qecho "libdir=${libdir}"
$qecho "lib64dir=${lib64dir}"
$qecho "bindir=${bindir}"
$qecho "sbindir=${sbindir}"
$qecho "sysconfdir=${sysconfdir}"
$qecho "datadir=${datadir}"
$qecho "pkgincludedir=${pkgincludedir}"
$qecho "pkglibdir=${pkglibdir}" 
$qecho "pkgdatadir=${pkgdatadir}"
$qecho "pkgsrcdir=${pkgsrcdir}"
$qecho "mandir=${mandir}"
$qecho "modsubdir=${modsubdir}"
$qecho

#
# Establish defaults
#

if [ -f $CONFIG ]; then
. $CONFIG
else
    USING_DEFAULTS=y
    CROSS_COMPILING=n
    TARGET=l
    CONFIG_STREAMS=m
    MOD_INSTALL=y
    KSRC=`default_ksrc`
    check_ksrc
    CONFIG_MK_KERNEL=n
    STRMS_QUEUES=t
    DBG_OPT=D
    LIS_SHLIB=y
    MACHINE=`uname -m`
# 23 Aug 2007 MarkS@Adax - Changed default for INT_PSW to n.
    INT_PSW=n
    STREAMS_REGPARM=${STREAMS_REGPARM:-0}
fi
unset CONFIG_DEV

#Not using KMEM Cache
#USE_KMEM_CACHE=y
unset USE_KMEM_CACHE

#Not using KMEM Timer
#USE_KMEM_TIMER=y
unset USE_KMEM_TIMER

if [ "$MACHINE" = "s390" -o "$MACHINE" = "s390x" ]; then
  SMP_GREP_ID='smp_num_cpus'
else
  SMP_GREP_ID='cpu_online_map'

fi

#
# TARGET
#
PROMPT="\
How do you want to configure STREAMS?\n\
    l = to run in the Linux kernel\n\
    u = to run in user level\n\
    q = to run under QNX (may not work)\n\
Please enter your choice"
RESPONSE="l u q"
DEFAULT="$TARGET"
ARGVVALUE="$OPT_LEVELRUN"
do_read_choice
TARGET=$RESULT

if [ "$TARGET" = "l" ]; then
    #
    # The linux target needs some special handling
    #
    PROMPT="\
Are you using the native Linux C compiler (y) or\n\
are you cross-compiling using a different compiler (n)?\n\
Native C (y) or cross-compile (n)?"
        RESPONSE="y n"
        ARGVVALUE=$OPT_NATIVECOMPILER
        do_read_choice
        case $RESULT in
	    y)
		CROSS_COMPILING=n
		;;
	    n)
		CROSS_COMPILING=y
		get_cross_compiler_info
		;;
        esac

    #
    # See if the GNU Libc stropts.h is an old version.  If so, substitute
    # the new 2.2 version.
    #
    if grep -w -q RDNORM /usr/include/sys/bits/stropts.h 2>/dev/null; then
	mv /usr/include/sys/bits/stropts.h /usr/include/sys/bits/stropts.h.orig
	cp -f ./include/sys/gnu.stropts.h /usr/include/sys/bits/stropts.h
	echo "Updated version of stropts.h installed in /usr/include/sys/bits"
    fi

    #
    # Verify kernel version, SMP and mod versions against the running
    # kernel if the user says that he/she intends to install on the
    # running kernel.
    #
    PROMPT="\
Do you intend to run LiS on this machine with\n\
the currently running kernel?"
    RESPONSE="y n"
    ARGVVALUE=${OPT_ONRUNNINGLNX}
    do_read_choice
    case $RESULT in
	y) USE_RUNNING_KERNEL=y ;;
	n) USE_RUNNING_KERNEL= ;;
    esac

    #
    # Kernel source location
    #
    if [ "$USE_RUNNING_KERNEL..." = "..." ]; then
	PROMPT="Enter directory location of your kernel source\n"
	DEFAULT=$KSRC
	if [ "$KSRC..." = "..." ]; then
	    DEFAULT="/lib/modules/`uname -r`/build"
	fi
	if [ ! -d "$KSRC" ]; then
	    DEFAULT="/usr/src/linux"
	    check_ksrc
	fi
        ARGVVALUE=${OPT_KSOURCEDIR}
	if do_read_dir; then
	    KSRC=$RESULT
	    NOKSRC=0
	    KINCL=$KSRC/include
	else
	    echo "Cannot locate kernel source."
	    echo "Will use /usr/include for header files."
	    KSRC=/usr
	    KINCL=$KSRC/include
	    NOKSRC=1
	fi
    else
	NOKSRC=0
	if [ -d $KSRC ]; then
	    : Retain default setting
	    KINCL=$KSRC/include
	    if [ ! -d $KINCL ]; then
	        KINCL=/lib/modules/$(uname -r)/build/include
	    fi
	elif [ -d /usr/src/linux ]; then
	    KSRC=/usr/src/linux
	    KINCL=$KSRC/include
	elif [ -d /usr/src/kernels/`uname -r`-`uname -m` ]; then
	    KSRC=/usr/src/kernels/`uname -r`-`uname -m`
	    KINCL=$KSRC/include
	else
	    echo
	    echo "No apparent kernel source directory.  LiS compilation"
	    echo "may very well fail.  If this should happen, load your"
	    echo "kernel source, or reinstall your kernel with source"
	    echo "and install LiS again."
	    echo
	    do_confirm
	    KSRC=/usr
	    KINCL=$KSRC/include
	    NOKSRC=1		# act as though no kernel source
	fi
	echo "Will use $KINCL for header files."
    fi

    # 17 Nov 2010 MarkS@Adax - in newer kernels (such as 2.6.34)
    # the autoconf.h file has been moved from include/linux directory
    # to the include/generated directory.  Check for autoconf.h in 
    # expected locations and set variable for use elsewhere in this 
    # script.  AUTOCONF_FILE is also written to config.in and used
    # by the modules/Makefile.2.6 and modules/.config files.
    if [ -f $KSRC/include/generated/autoconf.h ]; then
        AUTOCONF_FILE=$KSRC/include/generated/autoconf.h
    elif [ -f $KSRC/include/linux/autoconf.h ]; then
        AUTOCONF_FILE=$KSRC/include/linux/autoconf.h
    else
        # make sure AUTOCONF_FILE never ends up null otherwise its
        # use elsewhere in this script could result in a fatal error.
        AUTOCONF_FILE="AUTOCONF_FILE_NOTFOUND"
    fi

    #
    # Try to dig some info out of the kernel binary "vmlinux".  If we
    # can find out this stuff from the binary then we don't need the
    # .config file
    #
    get_kver
    get_smp
    get_xen
    get_modules
    get_ipv6
    get_ipv6_module
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	verify_kver
    fi
    get_regparm
    if [ $NEED_KSMP -eq 1 -o $NEED_KMODULES -eq 1 ]; then
	if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	    echo "Could not figure out whether or not your running kernel"
	    echo "was compiled with SMP or MODULES set.  Installation aborted."
	    exit 1
	fi
	NEED_KCONFIG=1		# couldn't access kernel binary
    else
	NEED_KCONFIG=0		# have info from kernel binary
    fi

    #
    # See if the kernel's .config file is there.  If not then the user
    # has not done a "make menuconfig" yet.
    #
    if [ $NOKSRC -eq 0 -a $NEED_KCONFIG -eq 1 -a ! -f $KSRC/.config ]; then
        PROMPT="\
It appears that you have not done a 'make menuconfig' on\n\
your kernel in $KSRC yet.  You should do that now to avoid\n\
problems with the installation.\n\
Do you want to do that now?"
        RESPONSE="y n"
        ## This is purely an interactive choice.. CLI options will avoid it
        unset ARGVVALUE
        do_read_choice
        case $RESULT in
	    y)
		    if ! make -C $KSRC menuconfig; then
		        echo "Menuconfig failed.  LiS installation aborted."
		        exit 1
		    fi
		    echo "Make menuconfig was successful."
		    echo "Continuing with LiS installation."
		    ;;
	    n)
		    echo "OK, but this may cause problems with the installation."
		    ;;
        esac
    fi

    #
    # If we have a kernel configuration now, source it.
    #
    if [ $NEED_KCONFIG -eq 1 -a -f $KSRC/.config ]; then
        . $KSRC/.config
    fi

    #
    # See if version.h is there.  It may not be if the user just unpacked
    # a fresh version of Linux and has not done a "make dep" yet.
    #
    if [ $NEED_KCONFIG -eq 1 ]; then
	check_kver
    fi
    #
    # Now see if there is one present.
    #
    if [ $NEED_KCONFIG -eq 1 -a ! -f $KSRC/include/linux/version.h ]; then
        PROMPT="\
It appears that you have not done a 'make dep' on your kernel yet.\n\
You will have to do this to proceed.\n\
Do you want to do that now?"
        RESPONSE="y n"
        ## This is purely an interactive choice.. CLI options will avoid it
        unset ARGVVALUE
        do_read_choice
        case $RESULT in
	    y)
	        if ! make -C $KSRC dep; then
	            echo "Make dep failed.  LiS installation aborted."
	            exit 1
	        fi
	        echo "Make dep was successful."
		echo "Continuing with LiS installation."
	        ;;
	    n)
		echo "LiS installation cannot proceed until this is done."
		echo "Please fix the problem and then try again."
		exit 1
		;;
        esac
    fi

    #
    # Kernel version
    #
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	echo "Running kernel is version $KVER"
    else
	DEFAULT=$KVER
	PROMPT="Which version of the kernel are you building for?\n"
        if [ "$OPT_VERSIONLINUX..." = "..." ]; then
	do_readstring
	KVER=$RESULT
        else
        KVER=${OPT_VERSIONLINUX}
        fi
    
	parse_kver $KVER
    fi

    if [ $KVER_MAJOR -lt 2 -o $KVER_MINOR -lt 3 ]; then
	echo
	echo "LiS is no longer compatible with Linux 1.x/2.0/2.2 kernels."
	echo
	exit 1
    fi

    #
    # CONFIG_STREAMS
    #
    # If we have concluded that the kernel does not support modules
    # then we need to inform the user of what is going on.  It is
    # next to impossible for a kernel not to support modules these
    # days.
    #
    if [ "$KMODULES" != "y" ]; then
	echo
	echo "Analysis of your kernel configuration suggests that your kernel"
	echo "does not support loadable modules.  This is extremely rare and"
	echo "is likely a result of mis-analysis of the kernel configuration"
	echo "files.  Installation will proceed as if the kernel supports"
	echo "loadable modules."
	echo 
    fi

    CONFIG_STREAMS=m

    #
    # See if the user wants STREAMS kernel loadable modules installed for
    # easy running.  Leaving the module for later loading is what is
    # needed for cross compiling.
    #
    PROMPT="\
After building STREAMS, do you want kernel loadable modules installed?\n\
This allows you to load it by typing in \"insmod streams\".\n\
    y = install it for module loading\n\
    n = just leave modules for later \"make modules_install\"\n\
Please enter y or n"
    RESPONSE="y n"
    DEFAULT="$MOD_INSTALL"
    ARGVVALUE=${OPT_LOADMODULES}
    do_read_choice
    MOD_INSTALL=$RESULT

    #
    # MOD_INST_DIR
    #
    # The old logic here was deleted - creating non-temporary directories
    # is a job for make install targets; our job here is just to choose a
    # directory name.
    #
    if [ "${DESTDIR}..." = "..." ]
    then
	    PROMPT="Enter desired kernel module directory\n"
    else
	    PROMPT="Enter desired kernel module directory relative to ${DESTDIR}\n"
    fi
    DEFAULT=/lib/modules/${KVER}/${modsubdir}
    do_readstring
    MOD_INST_DIR=`echo $RESULT | cleanup_dir`
    if [ ! -d ${DESTDIR}${MOD_INST_DIR} ]; then
	if ! mkdir -p ${DESTDIR}${MOD_INST_DIR}; then
	    echo "Could not make directory ${DESTDIR}${MOD_INST_DIR}"
	    echo "Configure aborting"
	    exit 1
	fi
    fi
    $qecho "Module installation directory will be ${DESTDIR}${MOD_INST_DIR}"

    #
    # STRMS_QUEUES
    #
    # Streams queues are always run as tasklets these days.
    #
    STRMS_QUEUES="t"

    if [ $NOKSRC -eq 1 -a "$KMODVERS..." = "y..." ]; then
	echo "Generating ${SRCDIR}/include/sys/modversions.h."
	rm -f include/sys/modversions.h
	generate_symbol_names > ${SRCDIR}/include/sys/modversions.h
	LISMODVERS=y
    fi


else # Not a Linux kernel target
    # These configuration items only make sense in the Linux kernel
    KSRC=
    KVER=
    CONFIG_MK_KERNEL=
    STRMS_QUEUES=
    MOD_INST_DIR=
    MOD_INSTALL=
    KSMP=
    KMODULES=
    CONFIG_STREAMS=
fi # Not a Linux kernel target

#
# LIS_OLD_CONSTS
#
if [ "$LIS_OLD_CONSTS..." = "..." ]; then
    LIS_OLD_CONSTS=n
fi
PROMPT="\
When you make STREAMS, do you want to use backward compatible constants\n\
in the file stropts.h?  If you answer No (the default) you will get\n\
constants that are compatible with UnixWare and Solaris, but which\n\
differ somewhat from previous versions of LiS.  If you answer Yes\n\
you will get constants that are compatible with previous versions of\n\
LiS but somewhat incompatible with UnixWare and Solaris.  If you\n\
intend to run application programs that were compiled with LiS-2.6\n\
or earlier then they have the old constants compiled into them and\n\
you should answer Yes to this question.\n\
    y = LiS backward compatible constants in stropts.h\n\
    n = UnixWare/Solaris compatible constants in stropts.h\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$LIS_OLD_CONSTS
ARGVVALUE=${OPT_BACKCOMPAT}
do_read_choice
LIS_OLD_CONSTS=$RESULT
if [ "$LIS_OLD_CONSTS..." = "y..." ]; then
    echo
    echo "When you compile your application programs you must include"
    echo "-DUSE_OLD_CONSTS on the command line so that your program"
    echo "uses the same values as LiS is being compiled with.  If you"
    echo "have an application program that was compiled with LiS-2.6"
    echo "or earlier then it has the old constants built into it."
    echo "It is to be preferred to use the new UnixWare/Solaris"
    echo "compatible constants as soon as it is practicable for you."
    echo
    do_confirm
fi

#
# SOLARIS_STYLE_CMN_ERR
#
if [ "$SOLARIS_STYLE_CMN_ERR..." = "..." ]; then
    SOLARIS_STYLE_CMN_ERR=n
fi
PROMPT="\
When you make STREAMS, do you want to use Solaris style cmn_err?\n\
In Solaris the newline goes on the end of the message.  For SVR4\n\
style cmn_err the newline goes on the beginning.\n\
    y = Solaris style cmn_err\n\
    n = SVR4 style cmn_err\n\
Please enter y or n"
RESPONSE="n y"
DEFAULT=$SOLARIS_STYLE_CMN_ERR
ARGVVALUE=${OPT_SOLARISSTYLE}
do_read_choice
SOLARIS_STYLE_CMN_ERR=$RESULT

#
# DBG_OPT
#
# Defaults to y for user build and to n for others
#
if [ "$DBG_OPT" = "D" ]; then
    if [ "$TARGET" = "u" ]; then
	DBG_OPT=y
    else
	DBG_OPT=n
    fi
fi
PROMPT="\
When you make STREAMS, do you want to compile for source level debugging?\n\
This is most useful when STREAMS is linked into the kernel and the\n\
gdbstub patch is installed in the kernel for kernel source level debugging.\n\
    y = set up for source level debugging\n\
    n = no source level debugging\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$DBG_OPT
ARGVVALUE=${OPT_SRCDBG}
do_read_choice
DBG_OPT=$RESULT


#
# LIS_SHLIB
#
if [ "$TARGET" = "l" ]; then
    PROMPT="\
Do you want to use shared libraries?
If you select static linking, you will get larger binaries that run by
themselves. If you select dynamic linking, the binaries will be smaller but
you will have to install the shared libraries in a directory that is in your
LD_LIBRARY_PATH environment variable.
    y = use dynamic linking with shared libraries\n\
    n = use static linking\n\
Please enter y or n"
    RESPONSE="y n"
    DEFAULT=$LIS_SHLIB
    ARGVVALUE=${OPT_SHAREDLIBS}
    do_read_choice
    LIS_SHLIB=$RESULT
else
    LIS_SHLIB=n
fi

# 23 Aug 2007 MarkS@Adax - Changed default response to "n" (INT_PSW=n) 
# for the below prompt so that CPU flags uses unsigned long by default 
# instead of an int.  This change is needed to support operation on 
# 2.4 64bit kernels (i.e. Red Hat EL 3 Update [5678] 64bit) and appears
# to work for all 2.4/2.6 32bit/64bit kernels supported by Adax.
#
# INT_PSW
#
if [ "$INT_PSW..." = "..." ]; then
    INT_PSW=n
fi
PROMPT="\
When you make STREAMS, do you want to use int type for CPU flags?\n\
Responding 'n' is more portable.  Only respond 'y' if problems were\n\
experienced using unsigned long for CPU flags.\n\
    y = int type for CPU flags\n\
    n = unsigned long type for CPU flags\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$INT_PSW
ARGVVALUE=${OPT_INTCPUFLAGS}
do_read_choice
INT_PSW=$RESULT

#
# CONFIG_DEV    -  Compile LiS for development or production.
#		   We ask the user the question with the opposite sense
#                  and then invert the answer for our internal flag.
#
# USE_KMEM_CACHE - Use level 2 cache memory for LiS queue and mblk structs
#                  for performance.
#
if [ "$CONFIG_DEV..." = "..." ]; then
    unset CONFIG_DEV
fi
PROMPT="\
When you make STREAMS, do you want LiS to be compiled in production mode?\n\
In this mode LiS will not audit queue, msg pointer, and internal LiS\n\
queue structure sanity for every STREAMs function call.  It will also\n\
use faster kernel allocations for messages.\n\
Responding 'y' is more appropriate for production environments\n\
Responding 'n' is more appropriate for development environments\n\
with verified modules/drivers.\n\
    y = Production mode\n\
    n = Development mode\n\
Please enter y or n"
RESPONSE="y n"
if [ "$CONFIG_DEV..." = "y..." ]; then
    DEFAULT=n
else
    DEFAULT=y
fi
ARGVVALUE="${OPT_PRODUCTIONCODE}"
do_read_choice
if [ "$RESULT..." = "y..." ]; then
    unset CONFIG_DEV

#Not using KMEM Cache
#   USE_KMEM_CACHE=y
    unset USE_KMEM_CACHE

#Not using KMEM Timer
#   USE_KMEM_TIMER=y
    unset USE_KMEM_TIMER
else
    CONFIG_DEV=y
    unset USE_KMEM_CACHE
    unset USE_KMEM_TIMER
fi

#
# Red Hat 7.1 needs a kludge related to including highmem.h from vmalloc.h.
#
if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/vmalloc.h ]; then
	if grep -q "Red Hat Linux 7.1" /proc/version &&
	   grep -q 'highmem\.h' $KSRC/include/linux/vmalloc.h; then
	    RH_71_KLUDGE=y
	fi
    fi
fi

#
# 2.4.20 (or thereabouts) changed the location of the signal mask lock
#
# Must set default to no.
SIGMASKLOCK=n

if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/sched.h ]; then
	if grep -q 'sigmask_lock' $KSRC/include/linux/sched.h; then
	    SIGMASKLOCK=y
	fi
    elif [ "$KVER_MAJORMINOR" = "2.4" -a $KVER_PATCHNO -ge 20 ]; then
	    SIGMASKLOCK=y
    elif [ "$KVER_MAJORMINOR" = "2.5" ]; then
	    SIGMASKLOCK=y
    elif [ "$KVER_MAJORMINOR" = "2.6" ]; then
	    SIGMASKLOCK=y
    fi
fi

#
# 2.6.11 changed sys_read and sys_write so that we can no longer use
# them for getpmsg/putpmsg.  We have to redefine those functions in
# libc/[get/put]pmsg.c to use ioctl if we are on 2.6.11 or later.
#
# 16 December 2005 MarkS@Adax - The above also applies to MontaVista
# Pro 4.0 kernel 2.6.10 (using existence of file .mvl_target_cpu as
# an indicator for MontaVista).
# 21 Dec 2007.  dg@adax - yep our good friends at MV backported the
# new file_operations structure, but didn't bother to backport the
# HAVE_UNLOCKED_IOCTL and HAVE_COMPAT_IOCTL macros from 2.6.11.
# The below works around this bug.
#
# Must set default to no.
GETMSG_PUTMSG_AS_IOCTL=n
LIS_HAVE_COMPAT_IOCTL=n

if [ "$TARGET" = "l" ]; then
    if [ "$KVER_MAJORMINOR" = "2.6" -a $KVER_PATCHNO -ge 10 ]; then
	if [ -e $KSRC/.mvl_target_cpu ]; then
	    GETMSG_PUTMSG_AS_IOCTL=y
	    LIS_HAVE_COMPAT_IOCTL=y
	fi
    fi
    if [ "$KVER_MAJORMINOR" = "2.6" -a $KVER_PATCHNO -ge 11 ]; then
	    GETMSG_PUTMSG_AS_IOCTL=y
    fi
fi

#
# 2.6.18 changed the header files to no longer include linux/config.h
# from the asm/param.h header file.  We have to add 
# -imacros $KSRC/linux/autoconf.h to get stuff to build.
#
# Must set default to no.
INCLUDE_AUTOCONF_H=n

if [ "$TARGET" = "l" ]; then
    if [ "$KVER_MAJORMINOR" = "2.6" -a $KVER_PATCHNO -ge 18 ]; then
	    INCLUDE_AUTOCONF_H=y
    fi
fi

#
# Red Hat changed the number of arguments in recalc_sigpending
#
if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/sched.h ]; then
	if grep -q 'recalc_sigpending(void)' $KSRC/include/linux/sched.h; then
	    RCVOID=y
	fi
    elif [ -f /usr/src/linux/include/linux/sched.h ]; then
	if grep -q 'recalc_sigpending(void)' \
		/usr/src/linux/include/linux/sched.h; then
	    RCVOID=y
	fi
    fi
fi


#
# Decide which C compiler to use.  gcc 2.96 is buggy, so try to use
# something better if it is present.
#
# The default is plain old gcc with -O2.
#
get_cc_from_makefile()
{
    make --no-print-directory -C $KSRC script 'SCRIPT=@echo $(CC)' | \
        sed -e 's/ .*//'
}

if   [ "$TARGET" = "l"  ]; then
    export KERN_CC_VERS=`kernel_cc_version`
    if [ "$KERN_CC_VERS..." = "..." ]; then
	echo
	echo "Could not determine the version of C compiler that was used"
	echo "to build your kernel.  Installation will proceed using the"
	echo "standard gcc compiler version `C_compiler_version gcc`, but"
	echo "there may be problems when you try to run LiS."
	echo
	do_confirm
# 23 Aug 2007 MarkS@Adax - next line was CC_NAME=gcc which isn't correct 
# if this is a cross compile (and won't work if using a 64bit cross 
# compiler on a 32bit host).  Now we call pick_a_c_compiler which will 
# return the compiler listed in the cross-compile file if one exists.
	CC_NAME=`pick_a_c_compiler`
	CC_VERS=`C_compiler_version gcc`
    else
	export CC_NAME=`pick_a_c_compiler`
	if [ "$CC_NAME..." = "..." ]; then
	    echo
	    echo "Could not identify a C compiler of version $KERN_CC_VERS."
	    echo "This compiler was used to compile your kernel and should"
	    echo "be used to compile LiS.  Installation will proceed using"
	    echo "the standard gcc compiler version `C_compiler_version gcc`,"
	    echo "but there may be problems when you try to run LiS."
	    echo
            # this is informative and should not block a batch configuration.
            if [ "$OPT_NATIVECOMPILER..." = "..." ] ;then
	    do_confirm
            fi
	    CC_NAME=gcc
	    CC_VERS=`C_compiler_version gcc`
	else
	    CC_VERS=`C_compiler_version cc`
	fi
    fi

    case $CC_NAME in
    kgcc)	CC_OPTIMIZE=-O3;;
    egcs)	CC_OPTIMIZE=-O3;;
    gcc3)	CC_OPTIMIZE=-O3;;
    gcc)	CC_OPTIMIZE=-O2;;
    cc)		CC_OPTIMIZE=-O2;;
    *)		CC_OPTIMIZE=-O2;;
    esac
    if $CC_NAME -mpreferred-stack-boundary=2 -S -o /dev/null -xc /dev/null \
	>/dev/null 2>&1
    then
	CC_OPT2=-mpreferred-stack-boundary=2
    fi
# 23 Aug 2007 MarkS@Adax - Added check for compiler support 
# of -funit-at-a-time option and set CC_OPT3 if supported.
# See config.mk for CC_OPT3 usage and more information.
    if $CC_NAME -funit-at-a-time -S -o /dev/null -xc /dev/null \
	>/dev/null 2>&1
    then
	CC_OPT3=-funit-at-a-time
    fi
# 18 Jul 2008 MarkS@Adax - Added check for compiler support 
# of -Wno-pointer-sign option and set CC_OPT4 if supported.
# See config.mk for CC_OPT4 usage and more information.
    if $CC_NAME -Wno-pointer-sign -S -o /dev/null -xc /dev/null \
	>/dev/null 2>&1
    then
	CC_OPT4=-Wno-pointer-sign
    fi
else
    echo
    echo "Non-Linux install.  Using cc as default C compiler."
    echo
    CC_NAME=cc
    CC_OPTIMIZE=-O
    CC_VERS=`C_compiler_version cc`
fi

if [ "$CC_VERS..." = "3.0.2..." ]; then
    echo
    echo "Compiler $CC_NAME $GCC_VERS is known to be buggy when"
    echo "compiling kernel code such as LiS.  You will probably"
    echo "experience problems, and perhaps crashes, when running LiS."
    echo
    do_confirm
fi

$qecho "Using \"$CC_NAME $CC_OPTIMIZE $CC_OPT2\" $CC_VERS as the C compiler"

#
# Some architectures need an additional include directory
# When installing with no kernel source we will use /usr/src/linux anyway
# and just hope that this stuff got installed even though the rest of the
# source is not there.
#
# 17 Nov 2010 MarkS@Adax - newer kernels (such as 2.6.34) have moved
# some header files out of the include directory structure and into
# the arch subdirectory structure.  Added KINCL_ARCH_INC below to 
# account for this migration of kernel header files.  We may need
# additional per architecture checks added below.  Note: the newer
# kernels do not appear to have arch/i386 nor arch/x86_64 and instead 
# have unified those two directories into arch/x86.  We may not be 
# able to rely on the $ARCH value set by LiS Configure which is "i386" 
# when building on x86 32-bit systems and "x86_64" when building on
# x86 64-bit systems.  This is why the below hardcodes the path as 
# arch/x86/include instead of using arch/$(ARCH)/include (which would 
# have been more useful) when building for i386 or x86_64.  All of the 
# below KINCL_ values may need to be re-examined in future to correctly 
# support kernel sources that have moved architecture specific header 
# files to the arch subdirectory structure.  And finally, KINCL_ARCH_INC 
# must be assigned a value BEFORE calling get_fs_h.
if [ "$ARCH" = "i386" -o "$ARCH" = "x86_64" ]
then
[ -e ${KSRC}/arch/x86/include ] && \
    KINCL_ARCH_INC="-I${KSRC}/arch/x86/include"
else
[ -e ${KSRC}/arch/${ARCH}/include ] && \
    KINCL_ARCH_INC="-I${KSRC}/arch/${ARCH}/include"
fi
# These are for Cavium SDK 1.8.1 and 1.9.0
[ -e ${KSRC}/include/asm/mach-generic ] && \
    KINCL_MACH_GENERIC="-I${KSRC}/include/asm/mach-generic"
[ -e ${KSRC}/arch/mips/include/asm/mach-generic ] && \
    KINCL_MACH_GENERIC="-I${KSRC}/arch/mips/include/asm/mach-generic"
[ -e ${KSRC}/include/asm/mach-default ] && \
    KINCL_MACH_DEFAULT="-I${KSRC}/include/asm/mach-default"
[ -e ${KSRC}/include/asm-mips/mach-cavium-octeon ] && \
    KINCL_MACH_CAVIUM_OCTEON="-I${KSRC}/include/asm-mips/mach-cavium-octeon"
[ -e ${KSRC}/arch/mips/include/asm/mach-cavium-octeon ] && \
    KINCL_MACH_CAVIUM_OCTEON="-I${KSRC}/arch/mips/include/asm/mach-cavium-octeon"
#
# Figure out which routine name to use for "get_empty_inode".
#
get_empty_inode_option
#
# Figure out whether or not set_cpus_allowed is defined in this kernel
#
set_cpus_allowed_option

# See if this stupid distro uses i_private or u.generic_ip in struct inode..
get_fs_h


# the following checks for post-2.4 kernels by version, but also
# sets some other related variables
#
check_kbuild


# identify GENCONF so we can create it here - it's a kosher config-time
# output (captures config info, lives inside the source tree, and building
# it from the top Makefile tends to make things circularly dependent)
#
GENCONF=${GENCONF:-${SRCDIR}/include/sys/LiS/genconf.h}

# create in each Makefile-containing directory a .config_mk file which can be
# included locally.  It in turn will include configuration-related make
# files or variables.  This allows any such directory to be made without
# starting at the top level (i.e., make -C <subdir>).  The existence of
# these files also signals that Configure has been run.
#
# note that CONFIG isn't additionally path-prefixed here, since we took
# care of expanding it above to include and absolute path prefix

# delete any old .config_mk files before writing new ones
#
find ${SRCDIR} -follow -name \.config_mk -exec rm {} \;

# find the subdirs with Makefile's in them
#
MAKE_DIRS=$(find ${SRCDIR} -follow -name Makefile -print | \
 	sed "s:^${SRCDIR}/::" | sed "s:/Makefile$::" | sed "s:^Makefile$:.:")

# clean up the list - convert it to the positional parms array, and set it
# again from that array.  This gets rid of newlines, extra whitespace, etc.
#
set -- ${MAKE_DIRS}
MAKE_DIRS="${@}"

# use the list to write a .config_mk in each directory.  We do this as
# a top-level file in SRCDIR and symlinks everywhere else
#
cat > ${SRCDIR}/.config_mk <<EOF
include ${CONFIG}
include ${SRCDIR}/config.mk
include ${SRCDIR}/quiet.mk
include ${SRCDIR}/version
EOF
for d in $MAKE_DIRS; do
    [ ! -f ${d}/.config_mk ] && ln -sf ${SRCDIR}/.config_mk ${d}/.config_mk || :
done

if [ -z "$ARCH" ]
then
	ARCH=`uname -m | sed -e s/i.86/i386/ \
			     -e s/sun4u/sparc64/ \
			     -e s/arm.*/arm/ \
			     -e s/sa110/arm/`
fi

if [ "$ARCH" = "mips" ]
then
	echo "MIPS target file system found."
	echo "Installing 32 libraries to /usr/lib32, not /usr/lib."
	libdir=`echo ${uprefix}/lib32 | cleanup_dir`
	pkglibdir=`echo ${libdir}/${package} | cleanup_dir`
fi

#
# Finally output configuration file
#

cfg_out()
{
    if [ $# = 2 ]; then
        echo "$1=$2" >>$CONFIG
    else
        echo "# $1 is not set" >>$CONFIG
    fi
}

cfg_out_str()
{
    if [ $# = 2 ]; then
        echo "$1=\"$2\"" >>$CONFIG
    else
        echo "# $1 is not set" >>$CONFIG
    fi
}

echo "" >$CONFIG
echo "# THIS FILE WAS GENERATED.  MANUAL CHANGES MAY BE LOST." >>$CONFIG
echo "" >>$CONFIG
cfg_out_str CONFIG_OPTS "$CONFIG_OPTS"
cfg_out CONFIG $CONFIG
cfg_out SRCDIR $SRCDIR
cfg_out GENCONF $GENCONF
cfg_out CONFIG_STREAMS $CONFIG_STREAMS
cfg_out TARGET $TARGET
if [ "$TARGET" = "l" ]; then
    cfg_out CROSS_COMPILING $CROSS_COMPILING
    cfg_out KSRC $KSRC
    cfg_out KINCL $KINCL
    cfg_out NOKSRC $NOKSRC
    cfg_out USE_RUNNING_KERNEL $USE_RUNNING_KERNEL
    cfg_out NKVER $NKVER
    cfg_out KVER $KVER
    cfg_out KVER_MAJOR $KVER_MAJOR
    cfg_out KVER_MINOR $KVER_MINOR
    cfg_out KVER_PATCH $KVER_PATCH
    cfg_out KVER_PATCHNO $KVER_PATCHNO
    cfg_out KVER_MAJORMINOR $KVER_MAJORMINOR
    cfg_out KVER_H $KVER_H
    cfg_out NKVER_H $NKVER_H
    cfg_out KSMP $KSMP
    cfg_out KXEN $KXEN
    cfg_out KMODULES $KMODULES
    cfg_out KMODVERS $KMODVERS
    cfg_out LISMODVERS $LISMODVERS
    cfg_out AUTOCONF_FILE $AUTOCONF_FILE
    cfg_out LISAUTOCONF $LISAUTOCONF
    cfg_out IPV6 $IPV6
    cfg_out IPV6_MODULE $IPV6_MODULE
    cfg_out CONFIG_MK_KERNEL $CONFIG_MK_KERNEL 
    cfg_out STRMS_QUEUES $STRMS_QUEUES
    cfg_out MOD_INST_DIR $MOD_INST_DIR
    cfg_out MOD_INSTALL $MOD_INSTALL
    cfg_out RH_71_KLUDGE $RH_71_KLUDGE
    cfg_out SIGMASKLOCK $SIGMASKLOCK
    cfg_out GETMSG_PUTMSG_AS_IOCTL $GETMSG_PUTMSG_AS_IOCTL
    cfg_out LIS_HAVE_COMPAT_IOCTL $LIS_HAVE_COMPAT_IOCTL
    cfg_out INCLUDE_AUTOCONF_H $INCLUDE_AUTOCONF_H
    cfg_out KINCL_ARCH_INC ${KINCL_ARCH_INC}
    cfg_out STRUCT_INODE_IPRIVATE $STRUCT_INODE_IPRIVATE
    cfg_out RCVOID $RCVOID
    cfg_out MACHINE $MACHINE
    cfg_out CC_NAME $CC_NAME
    cfg_out CC_NAME32 $CC_NAME32
    cfg_out CC_VERS $CC_VERS
    cfg_out CC_OPTIMIZE "$CC_OPTIMIZE"
    cfg_out CC_OPT2 "$CC_OPT2"
# 23 Aug 2007 MarkS@Adax - Added output of CC_OPT3 (see config.mk and above).
    cfg_out CC_OPT3 "$CC_OPT3"
# 18 Jul 2008 MarkS@Adax - Added output of CC_OPT4 (see config.mk and above).
    cfg_out CC_OPT4 "$CC_OPT4"
    cfg_out KINCL_MACH_GENERIC ${KINCL_MACH_GENERIC}
    cfg_out KINCL_MACH_CAVIUM_OCTEON ${KINCL_MACH_CAVIUM_OCTEON}
    cfg_out KINCL_MACH_DEFAULT ${KINCL_MACH_DEFAULT}
    cfg_out_str GET_EMPTY_INODE ${GET_EMPTY_INODE}
    cfg_out SET_CPUS_ALLOWED $SET_CPUS_ALLOWED
    #cfg_out REGISTER_SYSCALLS $REGISTER_SYSCALLS
    cfg_out INT_PSW $INT_PSW
    cfg_out CONFIG_DEV $CONFIG_DEV
    cfg_out USE_KMEM_CACHE $USE_KMEM_CACHE
    cfg_out USE_KMEM_TIMER $USE_KMEM_TIMER
    cfg_out LIS_MAJOR_BASE ${OPT_DEVICEBASE:-220}
    cfg_out CONFIG_INET $OPT_INET
    cfg_out PKGCOMPILE $OPT_PKGCOMPILE
    cfg_out PKGMODULES $OPT_PKGMODULES
    cfg_out SILENT_BUILD y
    cfg_out KBUILD $KBUILD
    cfg_out KBUILD_NEEDS_MODNAME $KBUILD_NEEDS_MODNAME
    cfg_out KBUILD_NEEDS_SYMVERS $KBUILD_NEEDS_SYMVERS
    cfg_out KBUILD_NEEDS_MODNAME_REDEF $KBUILD_NEEDS_MODNAME_REDEF
    cfg_out MODUTILS $MODUTILS
    cfg_out MODULE_INIT_TOOLS $MODULE_INIT_TOOLS
    cfg_out KSYMVERS $KSYMVERS
elif [ "$TARGET" = "u" ]; then
    cfg_out CONFIG_DEV y
fi
cfg_out CCREGPARM "$CCREGPARM"
cfg_out STREAMS_REGPARM "$STREAMS_REGPARM"
cfg_out LIS_OLD_CONSTS $LIS_OLD_CONSTS
cfg_out SOLARIS_STYLE_CMN_ERR $SOLARIS_STYLE_CMN_ERR
cfg_out DBG_OPT $DBG_OPT
cfg_out LIS_SHLIB $LIS_SHLIB
cfg_out package ${package}
cfg_out prefix ${prefix}
cfg_out execprefix ${execprefix}
cfg_out includedir ${includedir}
cfg_out libdir ${libdir}
cfg_out lib64dir ${lib64dir}
cfg_out bindir ${bindir}
cfg_out sbindir ${sbindir}
cfg_out sysconfdir ${sysconfdir}
cfg_out datadir ${datadir}
cfg_out pkgincludedir ${pkgincludedir}
cfg_out pkglibdir ${pkglibdir}
cfg_out pkgdatadir ${pkgdatadir}
cfg_out pkgsrcdir ${pkgsrcdir}
cfg_out mandir ${mandir}
cfg_out modsubdir ${modsubdir}
cfg_out_str MAKE_DIRS "$MAKE_DIRS"

# we know CONFIG now exists - create GENCONF; the script needs SRCDIR &
# CONFIG, & reads the just-created CONFIG
#
SRCDIR=${SRCDIR} CONFIG=${CONFIG} ${SRCDIR}/mkgenconf

if [ "$MAKE_INVOKED" != "y" ]; then
    $qecho
    $qecho "Warning:"
    $qecho \
"You did not use \"make\" or \"make configure\" to run this configuration"
    $qecho \
"script.  You can now just run \"make\" for the the top LiS source" 
    $qecho \
"directory, but you should run \"make config\" before directly making any"
    $qecho \
"of the LiS subdirectories that have a 'Makefile'."
fi
